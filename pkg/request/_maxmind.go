// Package request provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.2 DO NOT EDIT.
package request

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for RequestEventType.
const (
	RequestEventTypeAccountCreation RequestEventType = "account_creation"

	RequestEventTypeAccountLogin RequestEventType = "account_login"

	RequestEventTypeEmailChange RequestEventType = "email_change"

	RequestEventTypePasswordReset RequestEventType = "password_reset"

	RequestEventTypePurchase RequestEventType = "purchase"

	RequestEventTypeRecurringPurchase RequestEventType = "recurring_purchase"

	RequestEventTypeReferral RequestEventType = "referral"

	RequestEventTypeSurvey RequestEventType = "survey"
)

// Defines values for RequestPaymentProcessor.
const (
	RequestPaymentProcessorAdyen RequestPaymentProcessor = "adyen"

	RequestPaymentProcessorAltapay RequestPaymentProcessor = "altapay"

	RequestPaymentProcessorAmazonPayments RequestPaymentProcessor = "amazon_payments"

	RequestPaymentProcessorAuthorizenet RequestPaymentProcessor = "authorizenet"

	RequestPaymentProcessorBalanced RequestPaymentProcessor = "balanced"

	RequestPaymentProcessorBeanstream RequestPaymentProcessor = "beanstream"

	RequestPaymentProcessorBluepay RequestPaymentProcessor = "bluepay"

	RequestPaymentProcessorBraintree RequestPaymentProcessor = "braintree"

	RequestPaymentProcessorCcnow RequestPaymentProcessor = "ccnow"

	RequestPaymentProcessorChasePaymentech RequestPaymentProcessor = "chase_paymentech"

	RequestPaymentProcessorCielo RequestPaymentProcessor = "cielo"

	RequestPaymentProcessorCollector RequestPaymentProcessor = "collector"

	RequestPaymentProcessorCompropago RequestPaymentProcessor = "compropago"

	RequestPaymentProcessorConceptPayments RequestPaymentProcessor = "concept_payments"

	RequestPaymentProcessorConekta RequestPaymentProcessor = "conekta"

	RequestPaymentProcessorCuentadigital RequestPaymentProcessor = "cuentadigital"

	RequestPaymentProcessorDalpay RequestPaymentProcessor = "dalpay"

	RequestPaymentProcessorDibs RequestPaymentProcessor = "dibs"

	RequestPaymentProcessorDigitalRiver RequestPaymentProcessor = "digital_river"

	RequestPaymentProcessorEbs RequestPaymentProcessor = "ebs"

	RequestPaymentProcessorEcomm365 RequestPaymentProcessor = "ecomm365"

	RequestPaymentProcessorElavon RequestPaymentProcessor = "elavon"

	RequestPaymentProcessorEpay RequestPaymentProcessor = "epay"

	RequestPaymentProcessorEprocessingNetwork RequestPaymentProcessor = "eprocessing_network"

	RequestPaymentProcessorEway RequestPaymentProcessor = "eway"

	RequestPaymentProcessorFirstData RequestPaymentProcessor = "first_data"

	RequestPaymentProcessorGlobalPayments RequestPaymentProcessor = "global_payments"

	RequestPaymentProcessorHipay RequestPaymentProcessor = "hipay"

	RequestPaymentProcessorIngenico RequestPaymentProcessor = "ingenico"

	RequestPaymentProcessorInternetsecure RequestPaymentProcessor = "internetsecure"

	RequestPaymentProcessorIntuitQuickbooksPayments RequestPaymentProcessor = "intuit_quickbooks_payments"

	RequestPaymentProcessorIugu RequestPaymentProcessor = "iugu"

	RequestPaymentProcessorLemonPay RequestPaymentProcessor = "lemon_pay"

	RequestPaymentProcessorMastercardPaymentGateway RequestPaymentProcessor = "mastercard_payment_gateway"

	RequestPaymentProcessorMercadopago RequestPaymentProcessor = "mercadopago"

	RequestPaymentProcessorMerchantEsolutions RequestPaymentProcessor = "merchant_esolutions"

	RequestPaymentProcessorMirjeh RequestPaymentProcessor = "mirjeh"

	RequestPaymentProcessorMollie RequestPaymentProcessor = "mollie"

	RequestPaymentProcessorMonerisSolutions RequestPaymentProcessor = "moneris_solutions"

	RequestPaymentProcessorNmi RequestPaymentProcessor = "nmi"

	RequestPaymentProcessorOpenpaymx RequestPaymentProcessor = "openpaymx"

	RequestPaymentProcessorOptimalPayments RequestPaymentProcessor = "optimal_payments"

	RequestPaymentProcessorOrangepay RequestPaymentProcessor = "orangepay"

	RequestPaymentProcessorOther RequestPaymentProcessor = "other"

	RequestPaymentProcessorPacnetServices RequestPaymentProcessor = "pacnet_services"

	RequestPaymentProcessorPayfast RequestPaymentProcessor = "payfast"

	RequestPaymentProcessorPaygate RequestPaymentProcessor = "paygate"

	RequestPaymentProcessorPayone RequestPaymentProcessor = "payone"

	RequestPaymentProcessorPaypal RequestPaymentProcessor = "paypal"

	RequestPaymentProcessorPayplus RequestPaymentProcessor = "payplus"

	RequestPaymentProcessorPaystation RequestPaymentProcessor = "paystation"

	RequestPaymentProcessorPaytrace RequestPaymentProcessor = "paytrace"

	RequestPaymentProcessorPaytrail RequestPaymentProcessor = "paytrail"

	RequestPaymentProcessorPayture RequestPaymentProcessor = "payture"

	RequestPaymentProcessorPayu RequestPaymentProcessor = "payu"

	RequestPaymentProcessorPayulatam RequestPaymentProcessor = "payulatam"

	RequestPaymentProcessorPinpayments RequestPaymentProcessor = "pinpayments"

	RequestPaymentProcessorPrincetonPaymentSolutions RequestPaymentProcessor = "princeton_payment_solutions"

	RequestPaymentProcessorPsigate RequestPaymentProcessor = "psigate"

	RequestPaymentProcessorQiwi RequestPaymentProcessor = "qiwi"

	RequestPaymentProcessorQuickpay RequestPaymentProcessor = "quickpay"

	RequestPaymentProcessorRaberil RequestPaymentProcessor = "raberil"

	RequestPaymentProcessorRede RequestPaymentProcessor = "rede"

	RequestPaymentProcessorRedpagos RequestPaymentProcessor = "redpagos"

	RequestPaymentProcessorRewardspay RequestPaymentProcessor = "rewardspay"

	RequestPaymentProcessorSagepay RequestPaymentProcessor = "sagepay"

	RequestPaymentProcessorSimplifyCommerce RequestPaymentProcessor = "simplify_commerce"

	RequestPaymentProcessorSkrill RequestPaymentProcessor = "skrill"

	RequestPaymentProcessorSmartcoin RequestPaymentProcessor = "smartcoin"

	RequestPaymentProcessorSpsDecidir RequestPaymentProcessor = "sps_decidir"

	RequestPaymentProcessorStripe RequestPaymentProcessor = "stripe"

	RequestPaymentProcessorTelerecargas RequestPaymentProcessor = "telerecargas"

	RequestPaymentProcessorTowah RequestPaymentProcessor = "towah"

	RequestPaymentProcessorUsaEpay RequestPaymentProcessor = "usa_epay"

	RequestPaymentProcessorVerepay RequestPaymentProcessor = "verepay"

	RequestPaymentProcessorVindicia RequestPaymentProcessor = "vindicia"

	RequestPaymentProcessorVirtualCardServices RequestPaymentProcessor = "virtual_card_services"

	RequestPaymentProcessorVme RequestPaymentProcessor = "vme"

	RequestPaymentProcessorWorldpay RequestPaymentProcessor = "worldpay"
)

// Defines values for ResponseScoreDispositionAction.
const (
	ResponseScoreDispositionActionAccept ResponseScoreDispositionAction = "accept"

	ResponseScoreDispositionActionManualReview ResponseScoreDispositionAction = "manual_review"

	ResponseScoreDispositionActionReject ResponseScoreDispositionAction = "reject"
)

// Defines values for ResponseScoreDispositionReason.
const (
	ResponseScoreDispositionReasonCustomRule ResponseScoreDispositionReason = "custom_rule"

	ResponseScoreDispositionReasonDefault ResponseScoreDispositionReason = "default"
)

// Request defines model for Request.
type Request struct {
	// This object contains account information for the end-user on the site where the event took place.
	Account    *RequestAccount    `json:"account,omitempty"`
	Billing    *RequestAddress    `json:"billing,omitempty"`
	CreditCard *RequestCreditCard `json:"credit_card,omitempty"`

	// Custom Inputs are optional inputs to the minFraud service that must first be defined for your account. Select “Custom Inputs” from the Account Portal in order to do so. See our Custom Inputs documentation for more information.
	CustomInputs *RequestCustomInputs `json:"custom_inputs,omitempty"`

	// This object contains information about the device used in the transaction.
	Device RequestDevice `json:"device"`
	Email  *RequestEmail `json:"email,omitempty"`

	// This object contains general information related to the event being scored.
	Event    *RequestEvent    `json:"event,omitempty"`
	Order    *RequestOrder    `json:"order,omitempty"`
	Payment  *RequestPayment  `json:"payment,omitempty"`
	Shipping *RequestShipping `json:"shipping,omitempty"`

	// This is an array of shopping cart item objects. A shopping cart should consist of an array of one or more item objects.
	ShoppingCart *RequestShoppingCart `json:"shopping_cart,omitempty"`
}

// This object contains account information for the end-user on the site where the event took place.
type RequestAccount struct {
	// A unique user ID associated with the end-user in your system. If your system allows the login name for the account to be changed, this should not be the login name for the account, but rather should be an internal ID that does not change. This is not your MaxMind user ID.
	UserId *string `json:"user_id,omitempty"`

	// An MD5 hash as a hexadecimal string of the username or login name associated with the account.
	UsernameMd5 *string `json:"username_md5,omitempty"`
}

// RequestAddress defines model for Request.Address.
type RequestAddress struct {
	// The first line of the user’s billing address.
	Address *string `json:"address,omitempty"`

	// The second line of the user’s billing address.
	Address2 *string `json:"address_2,omitempty"`

	// The city of the user’s billing address.
	City *string `json:"city,omitempty"`

	// The company of the end user as provided in their billing information.
	Company *string `json:"company,omitempty"`

	// The two character [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the user’s billing address.
	Country *string `json:"country,omitempty"`

	// The first name of the end user as provided in their billing information.
	FirstName *string `json:"first_name,omitempty"`

	// The last name of the end user as provided in their billing information.
	LastName *string `json:"last_name,omitempty"`

	// The country code for phone number associated with the user’s billing address.
	PhoneCountryCode *string `json:"phone_country_code,omitempty"`

	// The phone number without the country code for the user’s billing address.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// The postal code of the user’s billing address.
	Postal *string `json:"postal,omitempty"`

	// The [ISO 3166-2 subdivision code](http://en.wikipedia.org/wiki/ISO_3166-2) for the user’s billing address.
	Region *string `json:"region,omitempty"`
}

// RequestCreditCard defines model for Request.CreditCard.
type RequestCreditCard struct {
	// The address verification system (AVS) check result, as returned to you by the credit card processor. The minFraud service supports the standard AVS codes.
	AvsResult *string `json:"avs_result,omitempty"`

	// The name of the issuing bank as provided by the end user.
	BankName *string `json:"bank_name,omitempty"`

	// The phone country code for the issuing bank as provided by the end user.
	BankPhoneCountryCode *string `json:"bank_phone_country_code,omitempty"`

	// The phone number, without the country code, for the issuing bank as provided by the end user.
	BankPhoneNumber *string `json:"bank_phone_number,omitempty"`

	// The card verification value (CVV) code as provided by the payment processor.
	CvvResult *string `json:"cvv_result,omitempty"`

	// The issuer ID number for the credit card. This is the first 6 digits of the credit card number. It identifies the issuing bank.
	IssuerIdNumber *string `json:"issuer_id_number,omitempty"`

	// The last four digits of the credit card number.
	Last4Digits *string `json:"last_4_digits,omitempty"`

	// A token uniquely identifying the card. The token should consist of non-space printable ASCII characters. If the token is all digits, it must be more than 19 characters long. The token must not be a primary account number (PAN) or a simple transformation of it. If you have a valid token that looks like a PAN but is not one, you may prefix that token with a fixed string, e.g., `token-`.
	Token *string `json:"token,omitempty"`
}

// Custom Inputs are optional inputs to the minFraud service that must first be defined for your account. Select “Custom Inputs” from the Account Portal in order to do so. See our Custom Inputs documentation for more information.
type RequestCustomInputs interface{}

// This object contains information about the device used in the transaction.
type RequestDevice struct {
	// The HTTP “Accept-Language” header of the device used in the transaction.
	AcceptLangauge *string `json:"accept_langauge,omitempty"`

	// The IP address associated with the device used by the customer in the transaction. The IP address must be in IPv4 or IPv6 presentation format, i.e., dotted-quad notation or the IPv6 hexadecimal-colon notation.
	IpAddress string `json:"ip_address"`

	// The HTTP “User-Agent” header of the browser used in the transaction.
	UserAgent *string `json:"user_agent,omitempty"`
}

// RequestEmail defines model for Request.Email.
type RequestEmail struct {
	// This field must be either be a valid email address or an MD5 of the email used in the transaction.
	Address *string `json:"address,omitempty"`

	// The domain of the email address used in the transaction.
	Domain *string `json:"domain,omitempty"`
}

// This object contains general information related to the event being scored.
type RequestEvent struct {
	// Your internal ID for the shop, affiliate, or merchant this order is coming from. Required for minFraud users who are resellers, payment providers, gateways and affiliate networks.
	ShopId *string `json:"shop_id,omitempty"`

	// The date and time the event occurred. The string must be in the [RFC 3339](https://tools.ietf.org/html/rfc3339) date-time format, e.g., “2012-04-12T23:20:50.52Z”. If this field is not in the request, the current time will be used.
	Time *string `json:"time,omitempty"`

	// Your internal ID for the transaction. We can use this to locate a specific transaction in our logs, and it will also show up in email alerts and notifications from us to you.
	TransactionId *string `json:"transaction_id,omitempty"`

	// The type of event being scored.
	Type *RequestEventType `json:"type,omitempty"`
}

// The type of event being scored.
type RequestEventType string

// RequestOrder defines model for Request.Order.
type RequestOrder struct {
	// The ID of the affiliate where the order is coming from.
	AffiliateId *string `json:"affiliate_id,omitempty"`

	// The total order amount for the transaction before taxes and discounts.
	Amount *float64 `json:"amount,omitempty"`

	// The [ISO 4217 currency code] (http://en.wikipedia.org/wiki/ISO_4217) for the currency used in the transaction.
	Currency *string `json:"currency,omitempty"`

	// The discount code applied to the transaction. If multiple discount codes were used, please separate them with a comma.
	DiscountCode *string `json:"discount_code,omitempty"`

	// Whether the purchaser included a gift message.
	HasGiftMessage *bool `json:"has_gift_message,omitempty"`

	// Whether order was marked as a gift by the purchaser.
	IsGift *bool `json:"is_gift,omitempty"`

	// The URI of the referring site for this order. Needs to be absolute and have a URI scheme such as `https://`.
	ReferrerUri *string `json:"referrer_uri,omitempty"`

	// The ID of the sub-affiliate where the order is coming from.
	SubaffiliateId *string `json:"subaffiliate_id,omitempty"`
}

// RequestPayment defines model for Request.Payment.
type RequestPayment struct {
	// The decline code as provided by your payment processor. If the transaction was not declined, do not include this field.
	DeclineCode *string `json:"decline_code,omitempty"`

	// If your payment processor is missing from this list, please contact [support@maxmind.com}(mailto:support@maxmind.com).
	Processor *RequestPaymentProcessor `json:"processor,omitempty"`

	// The authorization outcome from the payment processor. If the transaction has not yet been approved or denied, do not include this field.
	WasAuthorized *bool `json:"was_authorized,omitempty"`
}

// If your payment processor is missing from this list, please contact [support@maxmind.com}(mailto:support@maxmind.com).
type RequestPaymentProcessor string

// RequestShipping defines model for Request.Shipping.
type RequestShipping struct {
	// The first line of the user’s billing address.
	Address *string `json:"address,omitempty"`

	// The second line of the user’s billing address.
	Address2 *string `json:"address_2,omitempty"`

	// The city of the user’s billing address.
	City *string `json:"city,omitempty"`

	// The company of the end user as provided in their billing information.
	Company *string `json:"company,omitempty"`

	// The two character [ISO 3166-1 alpha-2 country code](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the user’s billing address.
	Country *string `json:"country,omitempty"`

	// The first name of the end user as provided in their billing information.
	FirstName *string `json:"first_name,omitempty"`

	// The last name of the end user as provided in their billing information.
	LastName *string `json:"last_name,omitempty"`

	// The country code for phone number associated with the user’s billing address.
	PhoneCountryCode *string `json:"phone_country_code,omitempty"`

	// The phone number without the country code for the user’s billing address.
	PhoneNumber *string `json:"phone_number,omitempty"`

	// The postal code of the user’s billing address.
	Postal *string `json:"postal,omitempty"`

	// The [ISO 3166-2 subdivision code](http://en.wikipedia.org/wiki/ISO_3166-2) for the user’s billing address.
	Region *string `json:"region,omitempty"`
}

// This is an array of shopping cart item objects. A shopping cart should consist of an array of one or more item objects.
type RequestShoppingCart []RequestShoppingCartItem

// RequestShoppingCartItem defines model for Request.ShoppingCartItem.
type RequestShoppingCartItem struct {
	// The category of the item.
	Category *string `json:"category,omitempty"`

	// Your internal ID for the item.
	ItemId *string `json:"item_id,omitempty"`

	// The per-unit price of this item in the shopping cart. This should use the same currency as the order currency.
	Price *float64 `json:"price,omitempty"`

	// The quantity of the item in the shopping cart.
	Quantity *int `json:"quantity,omitempty"`
}

// ResponseFactors defines model for Response.Factors.
type ResponseFactors struct {
	// Embedded struct due to allOf(#/components/schemas/Response.Score)
	ResponseScore `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	// This object contains minFraud response data associated with the billing address. If the billing address was not provided in the request or could not be parsed, this object will not be present in the response.
	BillingAddress *ResponseFactorsBillingAddress `json:"billing_address,omitempty"`

	// This object contains information about the device that MaxMind believes is associated with the IP address passed in the request.
	Device *ResponseFactorsDevice `json:"device,omitempty"`

	// This object contains minFraud response data associated with the shipping address. If the shipping address was not provided in the request or could not be parsed, this object will not be present in the response.
	Email     *ResponseFactorsEmail     `json:"email,omitempty"`
	IpAddress *ResponseFactorsIpAddress `json:"ip_address,omitempty"`

	// This object contains minFraud response data associated with the shipping address. If the shipping address was not provided in the request or could not be parsed, this object will not be present in the response.
	ShippingAddress *ResponseFactorsShippingAddress `json:"shipping_address,omitempty"`
}

// This object contains minFraud response data associated with the billing address. If the billing address was not provided in the request or could not be parsed, this object will not be present in the response.
type ResponseFactorsBillingAddress struct {
	// The distance in kilometers from the address to the IP location.
	DistanceToIpLocation *int `json:"distance_to_ip_location,omitempty"`

	// This field is true if the address is in the IP country. The field is false when the address is not in the IP country. If the IP address could not be geolocated, the field will not be included in the response.
	IsInIpCountry *bool `json:"is_in_ip_country,omitempty"`

	// This field is true if the postal code provided with the address is in the city for the address. The field is false when the postal code is not in the city.
	IsPostalInCity *bool `json:"is_postal_in_city,omitempty"`

	// The approximate latitude associated with the address.
	Latitude *float64 `json:"latitude,omitempty"`

	// The approximate longitude associated with the address.
	Longitude *float64 `json:"longitude,omitempty"`
}

// This object contains information about the device that MaxMind believes is associated with the IP address passed in the request.
type ResponseFactorsDevice struct {
	// A number from 0.01 to 99 representing the confidence that the `/device/id` refers to a unique device as opposed to a cluster of similar devices. A confidence of 0.01 indicates very low confidence that the device is unique, whereas 99 indicates very high confidence.
	Confidence *string `json:"confidence,omitempty"`

	// A UUID that MaxMind uses for the device associated with this IP address. Note that many devices cannot be uniquely identified because they are too common (for example, all iPhones of a given model and OS release). In these cases, the minFraud service will simply not return a UUID for that device. This is only available if you are using the [Device Tracking Add-on](https://dev.maxmind.com/minfraud/device/).
	Id *string `json:"id,omitempty"`

	// The date and time of the last sighting of the device. The value is formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339).
	LastSeen *string `json:"last_seen,omitempty"`
}

// This object contains minFraud response data associated with the shipping address. If the shipping address was not provided in the request or could not be parsed, this object will not be present in the response.
type ResponseFactorsEmail struct {
	// The distance in kilometers from the shipping address to billing address.
	DistanceToBillingAddress *int `json:"distance_to_billing_address,omitempty"`

	// The distance in kilometers from the address to the IP location.
	DistanceToIpLocation *int `json:"distance_to_ip_location,omitempty"`

	// This field is true if the shipping address is an address associated with fraudulent transactions. The field is false when the address is not associated with increased risk.
	IsHighRisk *bool `json:"is_high_risk,omitempty"`

	// This field is true if the shipping address is in the IP country. The field is false when the address is not in the IP country. If the IP address could not be geolocated, then the field will not be included in the response.
	IsInIpCountry *bool `json:"is_in_ip_country,omitempty"`

	// This field is true if the postal code provided with the address is in the city for the address. The field is false when the postal code is not in the city.
	IsPostalInCity *bool `json:"is_postal_in_city,omitempty"`

	// The approximate latitude associated with the address.
	Latitude *float64 `json:"latitude,omitempty"`

	// The approximate longitude associated with the address.
	Longitude *float64 `json:"longitude,omitempty"`
}

// ResponseFactorsIpAddress defines model for Response.Factors.IpAddress.
type ResponseFactorsIpAddress struct {
	// Embedded struct due to allOf(#/components/schemas/Response.Score.IpAddress)
	ResponseScoreIpAddress `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	City *struct {
		// Embedded fields due to inline allOf schema
		Confidence *int `json:"confidence,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"city,omitempty"`
	Continent *struct {
		// Embedded fields due to inline allOf schema
		Code *string `json:"code,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"continent,omitempty"`
	Country *struct {
		// Embedded fields due to inline allOf schema
		Confidence *int `json:"confidence,omitempty"`

		// This value is true if the IP country is high risk.
		IsHighRisk *bool   `json:"is_high_risk,omitempty"`
		IsoCode    *string `json:"iso_code,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"country,omitempty"`
	Location *struct {
		AccuracyRadius *int     `json:"accuracy_radius,omitempty"`
		AverageIncome  *int     `json:"average_income,omitempty"`
		Latitude       *float64 `json:"latitude,omitempty"`

		// The date and time of the transaction in the time zone associated with the IP address. The value is formatted according to [RFC 3339](https://tools.ietf.org/html/rfc3339). For instance, the local time in Boston might be returned as `2015-04-27T19:17:24-04:00`.
		LocalTime         *string  `json:"local_time,omitempty"`
		Longitude         *float64 `json:"longitude,omitempty"`
		MetroCode         *int     `json:"metro_code,omitempty"`
		PopulationDensity *int     `json:"population_density,omitempty"`
		TimeZone          *string  `json:"time_zone,omitempty"`
	} `json:"location,omitempty"`
	Postal *struct {
		Code       *string `json:"code,omitempty"`
		Confidence *int    `json:"confidence,omitempty"`
	} `json:"postal,omitempty"`
	RegisteredCountry *struct {
		// Embedded fields due to inline allOf schema
		IsoCode *string `json:"iso_code,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"registered_country,omitempty"`
	RepresentedCountry *struct {
		// Embedded fields due to inline allOf schema
		IsoCode *string `json:"iso_code,omitempty"`
		Type    *string `json:"type,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"represented_country,omitempty"`
	Subdivisons *struct {
		// Embedded fields due to inline allOf schema
		Confidence *int    `json:"confidence,omitempty"`
		IsoCode    *string `json:"iso_code,omitempty"`
		// Embedded struct due to allOf(#/components/schemas/Response.Factors.IpAddress.GeoName)
		ResponseFactorsIpAddressGeoName `yaml:",inline"`
	} `json:"subdivisons,omitempty"`
	Traits *struct {
		AutonomousSystemNumber       *int    `json:"autonomous_system_number,omitempty"`
		AutonomousSystemOrganization *string `json:"autonomous_system_organization,omitempty"`
		Domain                       *string `json:"domain,omitempty"`
		IpAddress                    *string `json:"ip_address,omitempty"`
		IsAnonymousProxy             *bool   `json:"is_anonymous_proxy,omitempty"`
		IsSatelliteProvider          *bool   `json:"is_satellite_provider,omitempty"`
		Isp                          *string `json:"isp,omitempty"`
		Organization                 *string `json:"organization,omitempty"`
		UserType                     *string `json:"user_type,omitempty"`
	} `json:"traits,omitempty"`
}

// ResponseFactorsIpAddressGeoName defines model for Response.Factors.IpAddress.GeoName.
type ResponseFactorsIpAddressGeoName struct {
	GeonameId *float32 `json:"geoname_id,omitempty"`
	Names     *struct {
		De   *string `json:"de,omitempty"`
		En   *string `json:"en,omitempty"`
		Es   *string `json:"es,omitempty"`
		Fr   *string `json:"fr,omitempty"`
		Ja   *string `json:"ja,omitempty"`
		PtBR *string `json:"pt-BR,omitempty"`
		Ru   *string `json:"ru,omitempty"`
		ZhCN *string `json:"zh-CN,omitempty"`
	} `json:"names,omitempty"`
}

// This object contains minFraud response data associated with the shipping address. If the shipping address was not provided in the request or could not be parsed, this object will not be present in the response.
type ResponseFactorsShippingAddress struct {
	// The distance in kilometers from the shipping address to billing address.
	DistanceToBillingAddress *int `json:"distance_to_billing_address,omitempty"`

	// The distance in kilometers from the address to the IP location.
	DistanceToIpLocation *int `json:"distance_to_ip_location,omitempty"`

	// This field is true if the shipping address is an address associated with fraudulent transactions. The field is false when the address is not associated with increased risk.
	IsHighRisk *bool `json:"is_high_risk,omitempty"`

	// This field is true if the shipping address is in the IP country. The field is false when the address is not in the IP country. If the IP address could not be geolocated, then the field will not be included in the response.
	IsInIpCountry *bool `json:"is_in_ip_country,omitempty"`

	// This field is true if the postal code provided with the address is in the city for the address. The field is false when the postal code is not in the city.
	IsPostalInCity *bool `json:"is_postal_in_city,omitempty"`

	// The approximate latitude associated with the address.
	Latitude *float64 `json:"latitude,omitempty"`

	// The approximate longitude associated with the address.
	Longitude *float64 `json:"longitude,omitempty"`
}

// ResponseInsights defines model for Response.Insights.
type ResponseInsights struct {
	// Embedded struct due to allOf(#/components/schemas/Response.Factors)
	ResponseFactors `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Subscores *ResponseInsightsSubscores `json:"subscores,omitempty"`
}

// ResponseInsightsSubscores defines model for Response.Insights.Subscores.
type ResponseInsightsSubscores struct {
	// The risk associated with the AVS result.
	AvsResult *float64 `json:"avs_result"`

	// The risk associated with the billing address.
	BillingAddress *float64 `json:"billing_address"`

	// The risk associated with the distance between the billing address and the location for the given IP address.
	BillingAddressDistanceToIpLocation *float64 `json:"billing_address_distance_to_ip_location"`

	// The risk associated with the browser attributes such as the User-Agent and Accept-Language.
	Browser *float64 `json:"browser"`

	// Individualized risk of chargeback for the given IP address on your account and shop ID.This is only available to users sending chargeback data to MaxMind.
	Chargeback *float64 `json:"chargeback"`

	// The risk associated with the country the transaction originated from.
	Country *float64 `json:"country"`

	// The risk associated with the combination of IP country, card issuer country, billing country, and shipping country.
	CountryMismatch *float64 `json:"country_mismatch"`

	// The risk associated with the CVV result.
	CvvResult *float64 `json:"cvv_result"`

	// The risk associated with the device.
	Device *float64 `json:"device"`

	// The risk associated with the device.
	EmailAddress *float64 `json:"email_address"`

	// The general risk associated with the email domain.
	EmailDomain *float64 `json:"email_domain"`

	// The risk associated with the email address local part (the part of the email address before the @ symbol).
	EmailLocalPart *float64 `json:"email_local_part"`

	// Please use [`email_address`]() instead.
	EmailTenure *float64 `json:"email_tenure"`

	// Please use [`risk_score`]() instead.
	IpTenure *float64 `json:"ip_tenure"`

	// The risk associated with the particular issuer ID number (IIN) given the billing location and the history of usage of the IIN on your account and shop ID.
	IssuerIdNumber *float64 `json:"issuer_id_number"`

	// The risk associated with the particular order amount for your account and shop ID.
	OrderAmount *float64 `json:"order_amount"`

	// The risk associated with the particular phone number.
	PhoneNumber *float64 `json:"phone_number"`

	// The risk associated with the shipping address.
	ShippingAddress *float64 `json:"shipping_address"`

	// The risk associated with the distance between the shipping address and the location for the given IP address.
	ShippingAddressDistanceToIpLocation *float64 `json:"shipping_address_distance_to_ip_location"`

	// The risk associated with the local time of day of the transaction in the IP address location.
	TimeOfDay *float64 `json:"time_of_day"`
}

// ResponseScore defines model for Response.Score.
type ResponseScore struct {
	// This object contains information about how a request was handled by the [custom rules](https://www.maxmind.com/en/minfraud-custom-rules) you have defined. If your account does not have any custom rules defined, then this object will not be present in the response.
	Disposition *ResponseScoreDisposition `json:"disposition,omitempty"`

	// The approximate US dollar value of the funds remaining on your MaxMind account.
	FundsRemaining *float64 `json:"funds_remaining,omitempty"`

	// This is the minFraud ID, a UUID that identifies the minFraud response. Use this ID to search your minFraud logs or when making support requests to MaxMind.
	Id        *string                 `json:"id,omitempty"`
	IpAddress *ResponseScoreIpAddress `json:"ip_address,omitempty"`

	// The approximate number of queries remaining for the service before your account runs out of funds.
	QueriesRemaining *int32 `json:"queries_remaining,omitempty"`

	// This field contains the risk score, from 0.01 to 99. A higher score indicates a higher risk of fraud. For example, a score of 20 indicates a 20% chance that a transaction is fraudulent. We never return a risk score of 0, since all transactions have the possibility of being fraudulent. Likewise we never return a risk score of 100.
	RiskScore *float64 `json:"risk_score,omitempty"`

	// Array of warnings.
	Warnings *ResponseScoreWarnings `json:"warnings,omitempty"`
}

// This object contains information about how a request was handled by the [custom rules](https://www.maxmind.com/en/minfraud-custom-rules) you have defined. If your account does not have any custom rules defined, then this object will not be present in the response.
type ResponseScoreDisposition struct {
	// This describes how the request was handled.
	Action *ResponseScoreDispositionAction `json:"action,omitempty"`

	// This describes why the `action` was set to a particular value.
	Reason *ResponseScoreDispositionReason `json:"reason,omitempty"`
}

// This describes how the request was handled.
type ResponseScoreDispositionAction string

// This describes why the `action` was set to a particular value.
type ResponseScoreDispositionReason string

// ResponseScoreIpAddress defines model for Response.Score.IpAddress.
type ResponseScoreIpAddress struct {
	// This field contains the risk associated with the IP address. The value ranges from 0.01 to 99. A higher score indicates a higher risk.
	Risk *float64 `json:"risk,omitempty"`
}

// Array of warnings.
type ResponseScoreWarnings []struct {
	// This value is a machine-readable code identifying the warning.
	Code *string `json:"code,omitempty"`

	// A JSON Pointer to the input field that the warning is associated with. For instance, if the warning was about the billing city, this would be `/billing/city`. If it was for the price in the second shopping cart item, it would be `/shopping_cart/1/price`.
	InputPointer *string `json:"input_pointer,omitempty"`

	// This field provides a human-readable explanation of the warning. The description may change at any time and should not be matched against.
	Warning *string `json:"warning,omitempty"`
}

// PostFactorsJSONBody defines parameters for PostFactors.
type PostFactorsJSONBody Request

// PostInsightsJSONBody defines parameters for PostInsights.
type PostInsightsJSONBody Request

// PostScoreJSONBody defines parameters for PostScore.
type PostScoreJSONBody Request

// PostFactorsJSONRequestBody defines body for PostFactors for application/json ContentType.
type PostFactorsJSONRequestBody PostFactorsJSONBody

// PostInsightsJSONRequestBody defines body for PostInsights for application/json ContentType.
type PostInsightsJSONRequestBody PostInsightsJSONBody

// PostScoreJSONRequestBody defines body for PostScore for application/json ContentType.
type PostScoreJSONRequestBody PostScoreJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostFactors request with any body
	PostFactorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFactors(ctx context.Context, body PostFactorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostInsights request with any body
	PostInsightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostInsights(ctx context.Context, body PostInsightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostScore request with any body
	PostScoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostScore(ctx context.Context, body PostScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostFactorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFactorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFactors(ctx context.Context, body PostFactorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFactorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInsightsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInsightsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostInsights(ctx context.Context, body PostInsightsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostInsightsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostScoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostScoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostScore(ctx context.Context, body PostScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostScoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostFactorsRequest calls the generic PostFactors builder with application/json body
func NewPostFactorsRequest(server string, body PostFactorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFactorsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFactorsRequestWithBody generates requests for PostFactors with any type of body
func NewPostFactorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/factors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostInsightsRequest calls the generic PostInsights builder with application/json body
func NewPostInsightsRequest(server string, body PostInsightsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInsightsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostInsightsRequestWithBody generates requests for PostInsights with any type of body
func NewPostInsightsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/insights")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostScoreRequest calls the generic PostScore builder with application/json body
func NewPostScoreRequest(server string, body PostScoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostScoreRequestWithBody(server, "application/json", bodyReader)
}

// NewPostScoreRequestWithBody generates requests for PostScore with any type of body
func NewPostScoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/score")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostFactors request with any body
	PostFactorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFactorsResponse, error)

	PostFactorsWithResponse(ctx context.Context, body PostFactorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFactorsResponse, error)

	// PostInsights request with any body
	PostInsightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInsightsResponse, error)

	PostInsightsWithResponse(ctx context.Context, body PostInsightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInsightsResponse, error)

	// PostScore request with any body
	PostScoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostScoreResponse, error)

	PostScoreWithResponse(ctx context.Context, body PostScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostScoreResponse, error)
}

type PostFactorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseFactors
}

// Status returns HTTPResponse.Status
func (r PostFactorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFactorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInsightsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseInsights
}

// Status returns HTTPResponse.Status
func (r PostInsightsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInsightsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostScoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseScore
}

// Status returns HTTPResponse.Status
func (r PostScoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostScoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostFactorsWithBodyWithResponse request with arbitrary body returning *PostFactorsResponse
func (c *ClientWithResponses) PostFactorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFactorsResponse, error) {
	rsp, err := c.PostFactorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFactorsResponse(rsp)
}

func (c *ClientWithResponses) PostFactorsWithResponse(ctx context.Context, body PostFactorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFactorsResponse, error) {
	rsp, err := c.PostFactors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFactorsResponse(rsp)
}

// PostInsightsWithBodyWithResponse request with arbitrary body returning *PostInsightsResponse
func (c *ClientWithResponses) PostInsightsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostInsightsResponse, error) {
	rsp, err := c.PostInsightsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInsightsResponse(rsp)
}

func (c *ClientWithResponses) PostInsightsWithResponse(ctx context.Context, body PostInsightsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostInsightsResponse, error) {
	rsp, err := c.PostInsights(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostInsightsResponse(rsp)
}

// PostScoreWithBodyWithResponse request with arbitrary body returning *PostScoreResponse
func (c *ClientWithResponses) PostScoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostScoreResponse, error) {
	rsp, err := c.PostScoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostScoreResponse(rsp)
}

func (c *ClientWithResponses) PostScoreWithResponse(ctx context.Context, body PostScoreJSONRequestBody, reqEditors ...RequestEditorFn) (*PostScoreResponse, error) {
	rsp, err := c.PostScore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostScoreResponse(rsp)
}

// ParsePostFactorsResponse parses an HTTP response from a PostFactorsWithResponse call
func ParsePostFactorsResponse(rsp *http.Response) (*PostFactorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostFactorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseFactors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostInsightsResponse parses an HTTP response from a PostInsightsWithResponse call
func ParsePostInsightsResponse(rsp *http.Response) (*PostInsightsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostInsightsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseInsights
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostScoreResponse parses an HTTP response from a PostScoreWithResponse call
func ParsePostScoreResponse(rsp *http.Response) (*PostScoreResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostScoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseScore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /factors)
	PostFactors(ctx echo.Context) error

	// (POST /insights)
	PostInsights(ctx echo.Context) error

	// (POST /score)
	PostScore(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostFactors converts echo context to params.
func (w *ServerInterfaceWrapper) PostFactors(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostFactors(ctx)
	return err
}

// PostInsights converts echo context to params.
func (w *ServerInterfaceWrapper) PostInsights(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInsights(ctx)
	return err
}

// PostScore converts echo context to params.
func (w *ServerInterfaceWrapper) PostScore(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostScore(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/factors", wrapper.PostFactors)
	router.POST(baseURL+"/insights", wrapper.PostInsights)
	router.POST(baseURL+"/score", wrapper.PostScore)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
